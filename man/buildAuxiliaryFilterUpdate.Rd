% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/auxiliaryFilterUpdate.R
\name{buildAuxiliaryFilterUpdate}
\alias{buildAuxiliaryFilterUpdate}
\title{Create an updated auxiliary particle filter algorithm to estimate log-likelihood.}
\usage{
buildAuxiliaryFilterUpdate(
  model,
  nodes,
  mvSamplesEst,
  target,
  control = list()
)
}
\arguments{
\item{model}{A NIMBLE model object, typically representing a state space model or a hidden Markov model.}

\item{nodes}{A character vector specifying the latent model nodes
over which the particle filter will stochastically integrate to
estimate the log-likelihood function.  All provided nodes must be stochastic.
Can be one of three forms: a variable name, in which case all elements in the variable
are taken to be latent (e.g., 'x'); an indexed variable, in which case all indexed elements are taken
to be latent (e.g., 'x[1:100]' or 'x[1:100, 1:2]'); or a vector of multiple nodes, one per time point,
in increasing time order (e.g., c("x[1:2, 1]", "x[1:2, 2]", "x[1:2, 3]", "x[1:2, 4]")).}

\item{mvSamplesEst}{A modelValue object contained posterior samples from the reduced model using MCMC.}

\item{control}{A list specifying different control options for the particle filter.  Options are described in the details section below.}
}
\description{
Create an updated auxiliary particle filter algorithm for a given NIMBLE state space model.
}
\details{

}
\examples{
## For illustration only.
stateSpaceCode <- nimbleCode({
  x0 ~ dnorm(0, var = 1)
  x[1] ~ dnorm(a* x0, var = 1)
  y[1] ~ dnorm(x[1]*c, var = .5)
  for(t in 2:10){
    x[t] ~ dnorm(a * x[t-1], var = 1)
    y[t] ~ dnorm(x[t]*c, var = .5)
  }
})

model <- nimbleModel(code = exampleCode, data = list(y = rnorm(10)),
                     inits = list(x0 = 0, x = rnorm(10)))
my_BootF <- buildAuxiliaryFilterUpdate(estimationModel,
latent,
mvSamplesEst = mvSamplesEst,
target = target,
control = pfControl)
## Now compile and run, e.g.,
## targetAsScalar <- estimationModel$expandNodeNames(target, returnScalarComponents = TRUE)
## compiledParticleFilter <- compileNimble(estimationModel,  particleFilterEst)
## logLik <- compiledParticleFilter$particleFilterEst$run(m = 2000, iterRun = 1, storeModelValues = values(estimationModel, targetAsScalar))
## ESS <- compiledParticleFilter$particleFilterEst$returnESS()
## boot_X <- as.matrix(compiledParticleFilter$particleFilterEst$mvEWSamples, 'x')
}
\references{
Michaud, N., de Valpine, P., Turek, D., Paciorek, C. J., & Nguyen, D. (2021). Sequential Monte Carlo methods in the nimble and nimbleSMC R packages. \emph{Journal of Statistical Software}. 100, 1-39.
}
\seealso{
Other smc update methods: 
\code{\link{buildBootstrapFilterUpdate}},
\code{\link{spartaNimUpdates}()},
\code{\link{spartaNimWeights}()},
\code{\link{updateUtils}()}
}
\author{
Kwaku Peprah Adjei
}
\concept{smc update methods}
